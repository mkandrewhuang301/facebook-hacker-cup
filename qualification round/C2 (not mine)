#include <bits/stdc++.h>
typedef long long ll;

using namespace std;

const ll INF = 2e14;

int t, n, k, c[1000];
ll dp[1000][1000][4], tmp[1000][4];
// dp[subtree][number of chains][configuration]
// config 0: root is not included at all
// config 1: root is included in a single-branch chain
// config 2: root is included in *at least* one dual-branch chain
idea is to use the chains and dfs from beginning. Set al values initally to zero except for base case no drills and doesnt include root (which is zero)
then you make all the states the possible drill number x and y. You want to test get the value [drill][condition] at the vertex as a sum of both x and y values 
then, once you made this temp dp, add it to the actual dp
Then , the last editing is where there is one chain or two chain
for the one chain, it is max of current and i-1 drills and the current vaue (extend chain)
for the all same chain except 1, get the i-1 drills and all double. We will extend one of the values up to the current node's parent
code by aditya sundaram
vector<int> g[50];

void dfs(int v, int p) {
///make original dp super negative
    for(int i = 0; i <= k; i++) {
        dp[v][i][0] = dp[v][i][1] = dp[v][i][2] = dp[v][i][3] = -INF;
    }
///base case: at node v with zero moves and root not included, there is a total of 0 gold you can obtain
    dp[v][0][0] = 0;
    for(int i: g[v]) {
        if(i != p) {
///dfs to get to bottom
            dfs(i, v);
///get temporary value for all states at node
            for(int x = 0; x < n; x++) {
                for(int y = 0; y < 4; y++) {
                    tmp[x][y] = dp[v][x][y];
                }
            }
            for(int x = 0; x < n; x++) {
                for(int y = 0; y < n; y++) {
 		    ///if bigger than largest node, continue
                    if(x + y >= n) {
                        continue;
                    }
                    tmp[x + y][0] = max(tmp[x + y][0], dp[v][x][0] + max({dp[i][y][0], dp[i][y][1], dp[i][y][2], dp[i][y][3]}));
                    tmp[x + y][1] = max(tmp[x + y][1], dp[v][x][0] + max({dp[i][y][1], dp[i][y][3]}) + c[v]);
                    tmp[x + y][1] = max(tmp[x + y][1], dp[v][x][1] + max({dp[i][y][0], dp[i][y][1], dp[i][y][2], dp[i][y][3]}));
                    if(x + y > 0) {
                        tmp[x + y - 1][2] = max(tmp[x + y - 1][2], max(dp[v][x][1], dp[v][x][3]) + max(dp[i][y][1], dp[i][y][3]));
                    }
                    tmp[x + y][2] = max(tmp[x + y][2], dp[v][x][2] + max({dp[i][y][0], dp[i][y][1], dp[i][y][2], dp[i][y][3]}));
                    tmp[x + y][3] = max(tmp[x + y][3], dp[v][x][2] + max({dp[i][y][1], dp[i][y][3]}));
                    tmp[x + y][3] = max(tmp[x + y][3], dp[v][x][3] + max({dp[i][y][0], dp[i][y][1], dp[i][y][2], dp[i][y][3]}));
                }
            }
            for(int x = 0; x < n; x++) {
                for(int y = 0; y < 4; y++) {
                    dp[v][x][y] = tmp[x][y];
                }
            }
        }
    }
    for(int i = n - 1; i > 0; i--) {
///  that state where 1 chain is either current or i-1 drills and connect the lower and current
        dp[v][i][1] = max(dp[v][i][1], dp[v][i - 1][0] + c[v]);
///same idea, dp where all chains connected use the k-1 drills abd break apart a path use that path
        dp[v][i][3] = max(dp[v][i][3], dp[v][i - 1][2]);
    }
}

int main() {
    freopen("gold_mine_chapter_2_input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
    cin >> t;
    for(int _ = 1; _ <= t; _++) {
        cin >> n >> k;
        for(int i = 0; i < n; i++) {
            cin >> c[i];
        }
///build graph
        for(int i = 0, u, v; i < n - 1; i++) {
            cin >> u >> v;
            g[u - 1].push_back(v - 1);
            g[v - 1].push_back(u - 1);
        }
        if(_ == 8) {
            continue;
        }
        cout << "Case #" << _ << ": ";
///remove k =  0 case
        if(k == 0 || n == 1) {
            cout << c[0] << endl;
            continue;
        }
///create dp
        dfs(0, 0);
///no need for k to be larger than n-1, since sufficient
        k = min(k, n - 1);
///only at the top, the best dp is just testing all k values, with the specified rules pos
        for(int i = 0; i < n; i++) {
            for(int j = 1; j <= k; j++) {
                for(int pos = 0; pos < 4; pos++) {
                    dp[i][j][pos] = max(dp[i][j][pos], dp[i][j - 1][pos]);
                }
            }
        }
///print largest. Either have k-1, where graph doesnt include root so need extra drill to reach, or all other conditions where reaches root
        cout << max({dp[0][k - 1][0], dp[0][k][1], dp[0][k][2], dp[0][k][3]}) << endl;
///reset the graph
        for(int i = 0; i < n; i++) {
            g[i].clear();
        }
    }
}
